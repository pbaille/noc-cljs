<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1443897239577">{:repl-history {:ide [], :local [&quot;(def p (atom [100 100]))&quot; &quot;(defn p-step [mx my]\n  (let [[x y] @p\n        diffx (- mx x)\n        diffy (- my y)]\n    [x y diffx diffy (/ diffy diffx)(/ diffx diffy)]\n    #_[(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))]\n    #_(reset! p [(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))])))&quot; &quot;(defn p-step [mx my]\n  (let [[x y] @p\n        diffx (- mx x)\n        diffy (- my y)\n        r (/ diffx diffy)]\n    [x y diffx diffy (/ diffx diffy) (/ r)]\n    #_[(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))]\n    #_(reset! p [(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))])))&quot; &quot;(p-step 200 101)&quot; &quot;(defn p-step [mx my delt]\n  (let [[x y] @p\n        diffx (- mx x)\n        diffy (- my y)\n        r (/ diffx diffy)]\n    [x y diffx diffy (/ diffx diffy) (/ r)]\n    #_[(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))]\n    #_(reset! p [(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))])))&quot; &quot;(p-step 0 90 3)&quot; &quot;(defn p-step [mx my delt]\n  (let [[x y] @p\n        diffx (- mx x)\n        diffy (- my y)\n        r (/ diffx diffy)\n        far-from-x (&gt; (abs x) (abs y))\n        x-shift (if far-from-x delt (* delt r))\n        y-shift (if far-from-x (* delt (/ r)) delt)]\n    [x y diffx diffy x-shift y-shift]\n    #_[(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))]\n    #_(reset! p [(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))])))&quot; &quot;(defn p-step [mx my delt]\n  (let [[x y] @p\n        diffx (- mx x)\n        diffy (- my y)\n        r (/ diffx diffy)\n        far-from-x (&gt; (abs diffx) (abs diffy))\n        x-shift (if far-from-x delt (* delt r))\n        y-shift (if far-from-x (* delt (/ r)) delt)]\n    [x y diffx diffy x-shift y-shift]\n    #_[(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))]\n    #_(reset! p [(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))])))&quot; &quot;(p-step 0 110 3)&quot; &quot;(defn p-step [mx my delt]\n  (let [[x y] @p\n        diffx (- mx x)\n        diffy (- my y)\n        r (/ diffx diffy)\n        far-from-x (&gt; (abs diffx) (abs diffy))\n        x-shift (if far-from-x delt (* delt r))\n        y-shift (if far-from-x (* delt (/ r)) delt)]\n    [x y diffx diffy x-shift y-shift]\n    #_[(+ x (* 3 (/ diffy diffx))) (+ y (* 3 (/ diffx diffy)))]\n    (reset! p [(+ x x-shift) (+ y y-shift)])))&quot; &quot;(rand)&quot; &quot;(drop-while (fn [[k v]] (&lt; k picked)) wm)&quot; &quot;(defn wrand [wm]\n  (let [sum (apply + (map second wm))\n        wm (reduce (fn [a e] (assoc a (+ (val e) (key (last a))) (key e))) (sorted-map) wm)\n        picked (* (rand sum))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(sorted-map)&quot; &quot;(defn wrand [wm]\n  (let [sum (apply + (map second wm))\n        [ks vs] ((juxt keys vals) wm)\n        vs (reduce + vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        picked (* (rand (last vs)))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [sum (apply + (map second wm))\n        [ks vs] ((juxt keys vals) wm)\n        vs (reductions + vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        picked (* (rand (last vs)))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        picked (* (rand (last vs)))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        picked (* (rand (last vs)))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + 0 vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        picked (* (rand (last vs)))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + 0 vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        _ (println wm)\n        picked (* (rand (last vs)))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + 0 vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        _ (println wm)\n        picked (* (rand) (last vs))]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + 0 vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        _ (println wm)\n        picked (* (rand) (last vs))\n        _ (println picked)]\n    (val (first (drop-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + 0 vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        _ (println wm)\n        picked (* (rand) (last vs))\n        _ (println picked)]\n    (drop-while (fn [[k v]] (&lt; k picked)) wm)))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + 0 vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        _ (println wm)\n        picked (* (rand) (last vs))\n        _ (println picked)]\n    (take-while (fn [[k v]] (&lt; k picked)) wm)))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        _ (println [ks vs])\n        vs (reductions + 0 vs)\n        _ (println vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        _ (println wm)\n        picked (* (rand) (last vs))\n        _ (println picked)]\n    (val (last (take-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(wrand {:a 4 :b 1})&quot; &quot;(defn p-step [mx my delt]\n  (let [[x y] @p\n        diffx (- mx x)\n        diffy (- my y)\n        [dx dy] (wrand {:t 1 :b 1 :r 2 :l 2})]\n\n    (reset! p [(+ x dx) (+ y dy)])))&quot; &quot;(ns noc.core\n  (:require [quil.core :refer :all]\n            [quil.middleware :as m]))&quot; &quot;(defn wrand [wm]\n  (let [[ks vs] ((juxt keys vals) wm)\n        vs (reductions + 0 vs)\n        wm (apply sorted-map (interleave (butlast vs) ks))\n        picked (* (rand) (last vs))]\n    (val (last (take-while (fn [[k v]] (&lt; k picked)) wm)))))&quot; &quot;(def dirs {:t [0 1] :b [0 -1] :r [1 0] :l [-1 0]\n           :tl [-1 1] :tr [1 1] :bl [-1 -1] :br [1 -1]})&quot; &quot;(defn dir-wrand [wm]\n  (wrand (into {} (map (fn [[k v]] [k (dirs v)]) wm))))&quot; &quot;(defn dir-wrand [wm]\n  (wrand (into {} (map (fn [[k v]] [(dirs k) v]) wm))))&quot; &quot;[[x y] @p\n        diffx (- mx x)\n        diffy (- my y)\n        [dx dy] (dir-wrand {:t 1 :b 1 :r 2 :l 2})]&quot; &quot;(dir-wrand {:t 1 :b 1 :r 2 :l 2})&quot; &quot;(defn setup []\n  ; draw will be called 60 times per second\n  (frame-rate 100)\n  (stroke 100)\n  (stroke-weight 1)\n  (smooth)\n  (reset! p [(/ (width) 2) (/ (height) 2)])\n  ; set background to white colour only in the setup\n  ; otherwise each invocation of 'draw' would clear sketch completely\n  (background 255))&quot; &quot;(def unidirand\n  (apply hash-map \n         (interleave \n           [:t :b :r :l :tl :tr :bl :br]\n           (repeat 1))))&quot; &quot;(defn draw []\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (- (* rx 500) 250)\n        y (- (* ry 500) 250)]\n    (println x y)\n    (ellipse  x y 50 50)))&quot; &quot;(defn draw []\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (- (* rx 500) 250)\n        y (- (* ry 500) 250)]\n    (println (int rx))\n    (ellipse  x y 50 50)))&quot; &quot;(defn draw []\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (- (* rx 500) 250)\n        y (- (* ry 500) 250)]\n    (println rx)\n    (ellipse  x y 50 50)))&quot; &quot;(defn draw []\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (* rx 500) 250\n        y (* ry 500) 250]\n    (println x y)\n    (ellipse  x y 50 50)))&quot; &quot;(defsketch noc\n           :title \&quot;You spin my circle right round\&quot;\n           :size [500 500]\n           ;:update update\n           :setup setup\n           :draw draw)&quot; &quot;(defn draw []\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (* rx 50) 250\n        y (* ry 50) 250]\n    (println x y)\n    (ellipse  x y 50 50)))&quot; &quot;(defn draw []\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (* rx 50)\n        y (* ry 50)]\n    (println x y)\n    (ellipse  x y 50 50)))&quot; &quot;(defn draw []\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (+ 250 (* rx 50))\n        y (+ 250 (* ry 50))]\n    (println x y)\n    (ellipse  x y 50 50)))&quot; &quot;(defn h [dispersion med-size size-disp]\n  (let [rx (random-gaussian)\n        ry (random-gaussian)\n        x (+ (/ (width) 2) (* rx dispersion))\n        y (+ (/ (height) 2) (* ry dispersion))\n        s (+ med-size (* (random-gaussian) size-disp))]\n    (ellipse  x y s s)))&quot; &quot;(noise (+ 1000 (/ (frame-count) 50)))&quot; &quot;(- 1000 (/ n2 2))&quot; &quot;(ns noc.fun-mode\n  (:require [quil.core :as q]\n            [quil.middleware :as m]))&quot; &quot;(defn v+ [v1 v2]\n  (v2 (+ (:x v1)(:x v2))\n      (+ (:y v1)(:y v2))))&quot; &quot;(defn v2 [x y]\n  {:x x :y y})&quot; &quot;(defn v+ [v1 v2]\n  (v2 (+ (:x v1) (:x v2))\n      (+ (:y v1) (:y v2))))&quot; &quot;(defn v+ [v1 v2]\n  (do\n    (println (+ (:x v1) (:x v2)))\n    (println (+ (:y v1) (:y v2)))\n    (v2 (+ (:x v1) (:x v2))\n        (+ (:y v1) (:y v2)))))&quot; &quot;(defn v+ [v1 v2]\n  {:x (+ (:x v1) (:x v2)) \n   :y (+ (:y v1) (:y v2))})&quot; &quot;(defn v+ [v1 v2]\n  {:x (+ (:x v1) (:x v2)) \n   :y (+ (:y v1) (:y v2))}\n  (v2 (+ (:x v1) (:x v2))\n      (+ (:y v1) (:y v2))))&quot; &quot;(v2 1 1)&quot; &quot;(v2 3 4)&quot; &quot;(v+ (v2 1 1) (v2 3 4))&quot; &quot;(defn draw [{{x :x y :y} :loc}]\n  (background 120)\n  (ellipse x y 25 25))&quot; &quot;(defn setup []\n  (stroke 125)\n  (stroke-weight 10)\n  {:loc (v2 250 250)\n   :vel (v2 0 0)\n   :acc (v2 1 0)})&quot; &quot;(defn draw [{{x :x y :y} :loc}]\n  (background 190)\n  (ellipse x y 25 25))&quot; &quot;(&gt; (width) x)&quot; &quot;(defn collision-handler [{{x :x y :y} :loc :as state}]\n  (cond \n    (&gt; (width) x) (assoc-in state [:loc :x] 0)\n    (&gt; 0 x) (assoc-in state [:loc :x] (width))\n    (&gt; (height) y) (assoc-in state [:loc :y] 0)\n    (&gt; 0 y) (assoc-in state [:loc :y] (height))))&quot; &quot;(defn vmax [vmx v]\n  {:x (min (:x vmx) (:x v))\n   :y (min (:y vmx) (:y v))})&quot; &quot;([^double x ^double y ^double z ^double w]\n          (Vector4D. x y z w))&quot; &quot;(defn v+\n  \&quot;Return the sum of one or more vectors.\&quot;\n  ([v] v)\n  ([v1 v2] (add* v1 v2))\n  ([v1 v2 &amp; more] (reduce add* v1 (cons v2 more))))&quot; &quot;(ns noc.fun-mode\n  (:require [quil.core :refer :all]\n            [quil.middleware :as m]\n            [utils.vecs :as v]))&quot; &quot;(Math/square 2)&quot; &quot;(defn mag [[a b]]\n  (Math/sqrt (+ (* a a) (* b b))))&quot; &quot;(defn norm [v]\n  (div v (mag v)))&quot; &quot;(ns noc.fun-mode\n  (:require [quil.core :refer :all]\n            [quil.middleware :as m]\n            [noc.utils.pv2 :refer :all]))&quot; &quot;(defn setup []\n  (stroke 125)\n  (stroke-weight 10)\n  {:loc     [250 250]\n   :vel     [0 0]\n   :acc     [0.1 0.2]\n   :max-vel 10})&quot; &quot;(defn collision-handler [{{x :x y :y} :loc :as state}]\n  (cond\n    (&gt; x (width)) (assoc-in state [:loc 0] 0)\n    (&gt; 0 x) (assoc-in state [:loc 0] (width))\n    (&gt; y (height)) (assoc-in state [:loc 1] 0)\n    (&gt; 0 y) (assoc-in state [:loc 1] (height))\n    :else state))&quot; &quot;(defn updx [[x y] z &amp; args] [(apply z x args) y])&quot; &quot;(ns noc.utils.mover\n  (:require [noc.utils.pv2 :refer :all]\n            [quil.core :refer :all]))&quot; &quot;(defn show-default [({[x y] :loc})]\n  (ellipse x y 50 50))&quot; &quot;(defn upd-default [{:keys [loc vel mass] :as m} &amp; forces]\n  (let [vel (reduce add vel (map #(div % mass) forces))]\n    (assoc m :vel vel :loc (add loc vel))))&quot; &quot;(defn mover [opts]\n  (merge opts \n         {:loc v0\n          :vel v0 \n          :mass 1\n          :show show-default\n          :upd upd-default}))&quot; &quot;(defn upd-default [{:keys [loc vel mass] :as m} forces]\n  (let [vel (reduce add vel (map #(div % mass) forces))]\n    (assoc m :vel vel :loc (add loc vel))))&quot; &quot;(defn show-default [{[x y] :loc}]\n  (ellipse x y 50 50))&quot; &quot;(defn mover [opts]\n  (merge opts\n         {:loc v0\n          :vel v0\n          :mass 1\n          :show show-default\n          :upd upd-default}))&quot; &quot;(defn upd [m &amp; fs] ((:upd m) fs))&quot; &quot;(defn apply-forces [{:keys [vel mass] :as m} fs]\n  (assoc v :vel (reduce add vel (map #(div % mass) fs))))&quot; &quot;(defn apply-forces [{:keys [vel mass] :as m} fs]\n  (assoc m :vel (reduce add vel (map #(div % mass) fs))))&quot; &quot;(fnil 1)&quot; &quot;(fnil)&quot; &quot;{:vel (rand 10)}&quot; &quot;(mover {:vel (rand 10)})&quot; &quot;(rand 10)&quot; &quot;(defn rand-mover [velrand locrand]\n    (mover {:vel [(rand velrand)(rand velrand)] \n            :loc [(rand locrand)(rand locrand)]}))&quot; &quot;(defn test1 []\n  (letfn [(rand-mover [velrand locrand]\n                      (mover {:vel [(rand velrand) (rand velrand)]\n                              :loc [(rand locrand) (rand locrand)]}))\n\n          (unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n                       (let [[w h] bounds]\n                         (assoc m :loc\n                                  (cond\n                                    (&gt; x w) (setx loc 0)\n                                    (&gt; 0 x) (setx loc w)\n                                    (&gt; y h) (sety loc 0)\n                                    (&gt; 0 y) (sety loc h)\n                                    :else loc))))]\n\n    (let [e (env\n              {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n               :actions  [unescapable]})\n          set (fn []\n                  (stroke 125)\n                  (stroke-weight 10)\n                  e)\n          upd (fn [e] ((:upd e) e))\n          draw (fn [e] ((:show e) e))]\n\n      (defsketch ex\n                 :size [500 500]\n                 :setup set\n                 :draw draw\n                 :update upd\n                 ; :mouse-moved mouse-moved\n                 :middleware [m/fun-mode])))\n  )&quot; &quot;(comment \&quot;test1\&quot;\n  (letfn [(rand-mover [velrand locrand]\n                      (mover {:vel [(rand velrand) (rand velrand)]\n                              :loc [(rand locrand) (rand locrand)]}))\n\n          (unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n                       (let [[w h] bounds]\n                         (assoc m :loc\n                                  (cond\n                                    (&gt; x w) (setx loc 0)\n                                    (&gt; 0 x) (setx loc w)\n                                    (&gt; y h) (sety loc 0)\n                                    (&gt; 0 y) (sety loc h)\n                                    :else loc))))]\n\n    (defn setup []\n      (stroke 125)\n      (stroke-weight 10)\n      (env\n        {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n         :actions  [unescapable]}))\n\n    (defn update [e] ((:upd e) e))\n\n    (defn draw [e] ((:show e) e))\n\n    (defsketch ex\n               :size [500 500]\n               :setup set\n               :draw draw\n               :update upd\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode]))\n  )&quot; &quot;(letfn [(rand-mover [velrand locrand]\n                      (mover {:vel [(rand velrand) (rand velrand)]\n                              :loc [(rand locrand) (rand locrand)]}))\n\n          (unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n                       (let [[w h] bounds]\n                         (assoc m :loc\n                                  (cond\n                                    (&gt; x w) (setx loc 0)\n                                    (&gt; 0 x) (setx loc w)\n                                    (&gt; y h) (sety loc 0)\n                                    (&gt; 0 y) (sety loc h)\n                                    :else loc))))]\n\n    (defn setup []\n      (stroke 125)\n      (stroke-weight 10)\n      (env\n        {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n         :actions  [unescapable]}))\n\n    (defn update [e] ((:upd e) e))\n\n    (defn draw [e] ((:show e) e))\n\n    (defsketch ex\n               :size [500 500]\n               :setup set\n               :draw draw\n               :update upd\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode]))&quot; &quot;(defn rand-mover [velrand locrand]\n    (mover {:vel [(rand velrand) (rand velrand)]\n            :loc [(rand locrand) (rand locrand)]}))&quot; &quot;(defn unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n    (let [[w h] bounds]\n      (assoc m :loc\n               (cond\n                 (&gt; x w) (setx loc 0)\n                 (&gt; 0 x) (setx loc w)\n                 (&gt; y h) (sety loc 0)\n                 (&gt; 0 y) (sety loc h)\n                 :else loc))))&quot; &quot;(defn setup []\n    (stroke 125)\n    (stroke-weight 10)\n    (env\n      {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n       :actions  [unescapable]}))&quot; &quot;(defn update [e] ((:upd e) e))&quot; &quot;(defn draw [e] ((:show e) e))&quot; &quot;(defsketch ex\n               :size [500 500]\n               :setup set\n               :draw draw\n               :update upd\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode])&quot; &quot;(defsketch ex\n               :size [500 500]\n               :setup setup\n               :draw draw\n               :update update\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode])&quot; &quot;(env\n      {:elements [(rand-mover 4 50)]\n       :actions  [unescapable]})&quot; &quot;(let [e (env\n            {:elements [(rand-mover 4 50)]\n             :actions  [unescapable]})]\n    (println e)\n    (println ((:upd e) e)))&quot;], :remote []}}</component>
</project>