<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1443897515340">{:repl-history {:ide [], :local [&quot;(defn norm [v]\n  (div v (mag v)))&quot; &quot;(ns noc.fun-mode\n  (:require [quil.core :refer :all]\n            [quil.middleware :as m]\n            [noc.utils.pv2 :refer :all]))&quot; &quot;(defn setup []\n  (stroke 125)\n  (stroke-weight 10)\n  {:loc     [250 250]\n   :vel     [0 0]\n   :acc     [0.1 0.2]\n   :max-vel 10})&quot; &quot;(defn collision-handler [{{x :x y :y} :loc :as state}]\n  (cond\n    (&gt; x (width)) (assoc-in state [:loc 0] 0)\n    (&gt; 0 x) (assoc-in state [:loc 0] (width))\n    (&gt; y (height)) (assoc-in state [:loc 1] 0)\n    (&gt; 0 y) (assoc-in state [:loc 1] (height))\n    :else state))&quot; &quot;(defn updx [[x y] z &amp; args] [(apply z x args) y])&quot; &quot;(ns noc.utils.mover\n  (:require [noc.utils.pv2 :refer :all]\n            [quil.core :refer :all]))&quot; &quot;(defn show-default [({[x y] :loc})]\n  (ellipse x y 50 50))&quot; &quot;(defn upd-default [{:keys [loc vel mass] :as m} &amp; forces]\n  (let [vel (reduce add vel (map #(div % mass) forces))]\n    (assoc m :vel vel :loc (add loc vel))))&quot; &quot;(defn mover [opts]\n  (merge opts \n         {:loc v0\n          :vel v0 \n          :mass 1\n          :show show-default\n          :upd upd-default}))&quot; &quot;(defn upd-default [{:keys [loc vel mass] :as m} forces]\n  (let [vel (reduce add vel (map #(div % mass) forces))]\n    (assoc m :vel vel :loc (add loc vel))))&quot; &quot;(defn show-default [{[x y] :loc}]\n  (ellipse x y 50 50))&quot; &quot;(defn mover [opts]\n  (merge opts\n         {:loc v0\n          :vel v0\n          :mass 1\n          :show show-default\n          :upd upd-default}))&quot; &quot;(defn upd [m &amp; fs] ((:upd m) fs))&quot; &quot;(defn apply-forces [{:keys [vel mass] :as m} fs]\n  (assoc v :vel (reduce add vel (map #(div % mass) fs))))&quot; &quot;(defn apply-forces [{:keys [vel mass] :as m} fs]\n  (assoc m :vel (reduce add vel (map #(div % mass) fs))))&quot; &quot;(fnil 1)&quot; &quot;(fnil)&quot; &quot;{:vel (rand 10)}&quot; &quot;(mover {:vel (rand 10)})&quot; &quot;(rand 10)&quot; &quot;(defn rand-mover [velrand locrand]\n    (mover {:vel [(rand velrand)(rand velrand)] \n            :loc [(rand locrand)(rand locrand)]}))&quot; &quot;(defn test1 []\n  (letfn [(rand-mover [velrand locrand]\n                      (mover {:vel [(rand velrand) (rand velrand)]\n                              :loc [(rand locrand) (rand locrand)]}))\n\n          (unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n                       (let [[w h] bounds]\n                         (assoc m :loc\n                                  (cond\n                                    (&gt; x w) (setx loc 0)\n                                    (&gt; 0 x) (setx loc w)\n                                    (&gt; y h) (sety loc 0)\n                                    (&gt; 0 y) (sety loc h)\n                                    :else loc))))]\n\n    (let [e (env\n              {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n               :actions  [unescapable]})\n          set (fn []\n                  (stroke 125)\n                  (stroke-weight 10)\n                  e)\n          upd (fn [e] ((:upd e) e))\n          draw (fn [e] ((:show e) e))]\n\n      (defsketch ex\n                 :size [500 500]\n                 :setup set\n                 :draw draw\n                 :update upd\n                 ; :mouse-moved mouse-moved\n                 :middleware [m/fun-mode])))\n  )&quot; &quot;(comment \&quot;test1\&quot;\n  (letfn [(rand-mover [velrand locrand]\n                      (mover {:vel [(rand velrand) (rand velrand)]\n                              :loc [(rand locrand) (rand locrand)]}))\n\n          (unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n                       (let [[w h] bounds]\n                         (assoc m :loc\n                                  (cond\n                                    (&gt; x w) (setx loc 0)\n                                    (&gt; 0 x) (setx loc w)\n                                    (&gt; y h) (sety loc 0)\n                                    (&gt; 0 y) (sety loc h)\n                                    :else loc))))]\n\n    (defn setup []\n      (stroke 125)\n      (stroke-weight 10)\n      (env\n        {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n         :actions  [unescapable]}))\n\n    (defn update [e] ((:upd e) e))\n\n    (defn draw [e] ((:show e) e))\n\n    (defsketch ex\n               :size [500 500]\n               :setup set\n               :draw draw\n               :update upd\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode]))\n  )&quot; &quot;(letfn [(rand-mover [velrand locrand]\n                      (mover {:vel [(rand velrand) (rand velrand)]\n                              :loc [(rand locrand) (rand locrand)]}))\n\n          (unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n                       (let [[w h] bounds]\n                         (assoc m :loc\n                                  (cond\n                                    (&gt; x w) (setx loc 0)\n                                    (&gt; 0 x) (setx loc w)\n                                    (&gt; y h) (sety loc 0)\n                                    (&gt; 0 y) (sety loc h)\n                                    :else loc))))]\n\n    (defn setup []\n      (stroke 125)\n      (stroke-weight 10)\n      (env\n        {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n         :actions  [unescapable]}))\n\n    (defn update [e] ((:upd e) e))\n\n    (defn draw [e] ((:show e) e))\n\n    (defsketch ex\n               :size [500 500]\n               :setup set\n               :draw draw\n               :update upd\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode]))&quot; &quot;(defn rand-mover [velrand locrand]\n    (mover {:vel [(rand velrand) (rand velrand)]\n            :loc [(rand locrand) (rand locrand)]}))&quot; &quot;(defn unescapable [{:keys [bounds] :as env} {[x y :as loc] :loc :as m}]\n    (let [[w h] bounds]\n      (assoc m :loc\n               (cond\n                 (&gt; x w) (setx loc 0)\n                 (&gt; 0 x) (setx loc w)\n                 (&gt; y h) (sety loc 0)\n                 (&gt; 0 y) (sety loc h)\n                 :else loc))))&quot; &quot;(defn setup []\n    (stroke 125)\n    (stroke-weight 10)\n    (env\n      {:elements (mapv (fn [_] (rand-mover 4 500)) (range 10))\n       :actions  [unescapable]}))&quot; &quot;(defn update [e] ((:upd e) e))&quot; &quot;(defn draw [e] ((:show e) e))&quot; &quot;(defsketch ex\n               :size [500 500]\n               :setup set\n               :draw draw\n               :update upd\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode])&quot; &quot;(defsketch ex\n               :size [500 500]\n               :setup setup\n               :draw draw\n               :update update\n               ; :mouse-moved mouse-moved\n               :middleware [m/fun-mode])&quot; &quot;(env\n      {:elements [(rand-mover 4 50)]\n       :actions  [unescapable]})&quot; &quot;(let [e (env\n            {:elements [(rand-mover 4 50)]\n             :actions  [unescapable]})]\n    (println e)\n    (println ((:upd e) e)))&quot; &quot;(range 25 0)&quot; &quot;(reverse (range 25))&quot; &quot;(defn show-mover [{[x y] :loc}]\n    (for [n (reverse (range 25))]\n      (do\n        (fill 0 0 0 10)\n        (ellipse x y (* n 2)(* n 2)))))&quot; &quot;(range 0.5 2 0.25)&quot; &quot;(map-indexed vector [:a :b :elements])&quot; &quot;(pow 10 10)&quot; &quot;(let [a [1 2 3 4]]\n  (concat (take 2 a) (drop 2 a)))&quot; &quot;(let [a [1 2 3 4]]\n  (concat (take 2 a) (next (drop 2 a))))&quot; &quot;(let [a [1 2 3 4]]\n     (concat (take 2 a) (next (drop 2 a))))&quot; &quot;(def movers\n    (map\n      (fn []\n        {:vel  [(rand 3) (rand 3)]\n         :loc  [(rand 500) (rand 500)]\n         :show (fn [{[x y] :loc}] (ellipse x y 50 50))\n         :mass (rand-nth (range 0.5 2 0.25))\n         :act  gravitation\n         :age  (int (* 1000 (rand)))})\n      (range 15)))&quot; &quot;(map\n      (fn []\n        {:vel  [(rand 3) (rand 3)]\n         :loc  [(rand 500) (rand 500)]\n         :show (fn [{[x y] :loc}] (ellipse x y 50 50))\n         :mass (rand-nth (range 0.5 2 0.25))\n         :act  gravitation\n         :age  (int (* 1000 (rand)))})\n      (range 15))&quot; &quot;(map\n      (fn [_]\n        {:vel  [(rand 3) (rand 3)]\n         :loc  [(rand 500) (rand 500)]\n         :show (fn [{[x y] :loc}] (ellipse x y 50 50))\n         :mass (rand-nth (range 0.5 2 0.25))\n         :act  gravitation\n         :age  (int (* 1000 (rand)))})\n      (range 15))&quot; &quot;(apply elements movers)&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (println \&quot;hey\&quot;)\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (concat (take i es) (drop (inc i) es))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (println \&quot;hey\&quot;)\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (concat (take i es) (when (&lt; i cnt) (drop (inc i) es)))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (println \&quot;hey\&quot;)\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (concat (take i es) (if (&lt; i cnt) (drop (inc i) es) ()))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (println \&quot;hey\&quot;)\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (println (if (&lt; i cnt) (drop (inc i) es) ()))\n                         (concat (take i es) (if (&lt; i cnt) (drop (inc i) es) ()))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (concat (take i es) (if (&lt; i cnt) (drop (inc i) es) ()))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(def movers\n    (map\n      (fn [_]\n        {:vel  [(rand 3) (rand 3)]\n         :loc  [(rand 500) (rand 500)]\n         :show (fn [{[x y] :loc}] (ellipse x y 50 50))\n         :mass (rand-nth (range 0.5 2 0.25))\n         :act  gravitation\n         :age  (int (* 1000 (rand)))})\n      (range 15)))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println i) (if (act? e y) (act e y) y))\n                         (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ()))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(take 0 [1 2])&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println y) (if (act? e y) (act e y) y))\n                         (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ()))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (do (println (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ()))) \n                             (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println \&quot;item\&quot; y) (if (act? e y) (act e y) y))\n                         (do (println \&quot;list\&quot; (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ()))) \n                             (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println \&quot;item\&quot; y) (if (act? e y) (act e y) y))\n                         (let [_ (println \&quot;list\&quot; (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))] \n                             (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println \&quot;item\&quot; y) (if (act? e y) (act e y) y))\n                         (let [#_(println \&quot;list\&quot; (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))] \n                             (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println \&quot;item\&quot; y) (println \&quot;ret \&quot; (if (act? e y) (act e y) y)) (if (act? e y) (act e y) y))\n                         (let [#_(println \&quot;list\&quot; (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))]\n                             (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println \&quot;act?\&quot; (act? e y)) (if (act? e y) (act e y) y))\n                         (let [#_(println \&quot;list\&quot; (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))]\n                             (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (println \&quot;act?\&quot; (:act? e)) (if (act? e y) (act e y) y))\n                         (let [#_(println \&quot;list\&quot; (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))]\n                             (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ())))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (concat (take i es) (if (&lt; i (dec cnt)) (drop (inc i) es) ()))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [cnt (count xs)\n        r (reduce (fn [es [i e]]\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (concat (take i es) (drop (inc i) es) ())))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (map (fn [y] (if (act? e y) (act e y) y))\n                         (concat (take i es) (drop (inc i) es))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(.printStackTrace *e)&quot; &quot;(def movers\n    (map\n      (fn [_]\n        (element\n          {:vel  [(rand 3) (rand 3)]\n           :loc  [(rand 500) (rand 500)]\n           :show (fn [{[x y] :loc}] (ellipse x y 50 50))\n           :mass (rand-nth (range 0.5 2 0.25))\n           :act  gravitation\n           :age  (int (* 1000 (rand)))}))\n      (range 15)))&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (map (fn [y] (= e y) (if (act? e y) (act e y) y))\n                         (concat (take i es) (drop (inc i) es))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (map (fn [y] (println (= e y)) (if (act? e y) (act e y) y))\n                         (concat (take i es) (drop (inc i) es))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(drop 4 [1 2 3 4])&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (map (fn [y] (println [(:loc e) (:loc y)]) (if (act? e y) (act e y) y))\n                         (concat (take i es) (drop (inc i) es))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (map (fn [y] (println [(:loc e) (:loc y)]) (if (act? e y) (act e y) y))\n                         (do (println \&quot;ert\&quot;\n                                      (map :loc (concat (take i es) (drop (inc i) es)))) \n                             (concat (take i es) (drop (inc i) es)))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (concat [e] \n                            (map (fn [y] (if (act? e y) (act e y) y)) \n                                 (concat (take i es) (drop (inc i) es)))))\n                  xs\n                  (map-indexed vector xs))]\n    (println \&quot;yop\&quot; r)\n    r))&quot; &quot;(do-interactions movers)&quot; &quot;(defn apply-force [{:keys [vel mass] :as m} f]\n  (assoc m :vel (add vel (div f mass))))&quot; &quot;(element \n      {:loc [250 250]\n       :mass 10000\n       :show (fn [_] (background 0))\n       :act (fn [x y] (apply-force y [0 0.01]))})&quot; &quot;(p (first movers))&quot; &quot;[borders (first movers)]&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (let [f (fn [y] (if (act? e y) (act e y) y))]\n                      (concat (map f (take i es)) [e] (map f (drop (inc i) es)))))\n                  xs\n                  (map-indexed vector xs))]\n    #_(mapv p r)\n    r))&quot; &quot;(def borders\n    (element\n      {:mass 10000\n       :show (fn [_] ())\n       :step (fn [x] x)\n       :fixed true\n       :act  (fn [_ {[x y] :loc :as t}]\n               (cond\n                 (&gt; x (- 500 75)) (apply-force t [-1 0])\n                 (&lt; x 75) (apply-force t [1 0])\n                 (&gt; y (- 500 75)) (apply-force t [0 -1])\n                 (&lt; y 75) (apply-force t [0 1])\n                 :else t))}))&quot; &quot;(defn do-interactions [xs]\n  (let [r (reduce (fn [es [i e]]\n                    (let [f (fn [y] (if (act? e y) (act e y) y))]\n                      (concat (map f (take i es)) [e] (map f (drop (inc i) es)))))\n                  xs\n                  (map-indexed vector xs))]\n    (mapv p r)\n    r))&quot; &quot;(def borders\n    (element\n      {:mass 10000\n       :show (fn [_] ())\n       :step (fn [x] x)\n       :fixed true\n       :act  (fn [b {[x y] :loc :as t}]\n               (println \&quot;bact\&quot;)\n               (p b) (p t)\n               (cond\n                 (&gt; x (- 500 75)) (apply-force t [-1 0])\n                 (&lt; x 75) (apply-force t [1 0])\n                 (&gt; y (- 500 75)) (apply-force t [0 -1])\n                 (&lt; y 75) (apply-force t [0 1])\n                 :else t))}))&quot; &quot;(do-interactions [borders (first movers)])&quot; &quot;(element {:loc 450 250})&quot; &quot;(element {:loc [450 250]})&quot; &quot;(def borders\n    (element\n      {:mass  10000\n       :show  (fn [_] ())\n       :step  (fn [x] x)\n       :fixed true\n       :act   (fn [b {[x y] :loc :as t}]\n                (println \&quot;bact\&quot;)\n                (p b) (p t)\n                (let [r (cond\n                        (&gt; x (- 500 75)) (apply-force t [-1 0])\n                        (&lt; x 75) (apply-force t [1 0])\n                        (&gt; y (- 500 75)) (apply-force t [0 -1])\n                        (&lt; y 75) (apply-force t [0 1])\n                        :else t)]\n                  (println \&quot;r\&quot; r)\n                  r))}))&quot; &quot;(do-interactions [borders (element {:loc [450 250]})])&quot; &quot;(nth 1 [1 2 3])&quot; &quot;(nth [1 2 3] 1)&quot; &quot;(defn distant-interaction [sign limit]\n    (fn [x y]\n      (let [dist (sub (:loc x) (:loc y))\n            ma (magn dist)\n            fma (/ (* G (:mass x) (:mass y)) (* ma ma))\n            f (-&gt; dist normalize (mult (sign fma)) (lim limit))]\n        (update-in y [:vel] #(add % f)))))&quot; &quot;(def gravitation (distant-interaction + 0.2))&quot; &quot;(def repulsion (distant-interaction - 0.2))&quot; &quot;(defn borders [bounds rf]\n    (element\n      {:mass  10000\n       :show  (fn [_] ())\n       :step  (fn [x] x)\n       :fixed true\n       :act   (fn [b {[x y] :loc :as t}]\n                (let [closestx (if (&gt; (abs (- 500 x)) (abs x)) 0 500)\n                      closesty (if (&gt; (abs (- 500 y)) (abs y)) 0 500)]\n                  (println \&quot;bact\&quot; closestx closesty)\n                  #_(repulsion {:loc [closestx closesty] :mass 2} t)))}))&quot; &quot;(defn borders [bounds rf]\n    (element\n      {:mass  10000\n       :show  (fn [_] ())\n       :step  (fn [x] x)\n       :fixed true\n       :act   (fn [b {[x y] :loc :as t}]\n                \&quot;yo\&quot;\n                (let [closestx (if (&gt; (abs (- 500 x)) (abs x)) 0 500)\n                      closesty (if (&gt; (abs (- 500 y)) (abs y)) 0 500)]\n                  (println \&quot;bact\&quot; closestx closesty)\n                  #_(repulsion {:loc [closestx closesty] :mass 2} t)))}))&quot; &quot;(element\n      {:mass  10000\n       :show  (fn [_] ())\n       :step  (fn [x] x)\n       :fixed true\n       :act   (fn [b {[x y] :loc :as t}]\n                \&quot;yo\&quot;\n                (let [closestx (if (&gt; (abs (- 500 x)) (abs x)) 0 500)\n                      closesty (if (&gt; (abs (- 500 y)) (abs y)) 0 500)]\n                  (println \&quot;bact\&quot; closestx closesty)\n                  #_(repulsion {:loc [closestx closesty] :mass 2} t)))})&quot; &quot;(defn borders [bounds rf]\n    (element\n      {:mass  10000\n       :show  (fn [_] ())\n       :step  (fn [x] x)\n       :fixed true\n       :act   (fn [b {[x y] :loc :as t}]\n                (println \&quot;yo\&quot;)\n                (let [closestx (if (&gt; (abs (- 500 x)) (abs x)) 0 500)\n                      closesty (if (&gt; (abs (- 500 y)) (abs y)) 0 500)]\n                  (println \&quot;bact\&quot; closestx closesty)\n                  #_(repulsion {:loc [closestx closesty] :mass 2} t)))}))&quot; &quot;(first movers)&quot; &quot;(def borders \n    (element\n      {:mass  10000\n       :show  (fn [_] ())\n       :step  (fn [x] x)\n       :fixed true\n       :act   (fn [b {[x y] :loc :as t}]\n                (println \&quot;yo\&quot;)\n                (let [closestx (if (&gt; (abs (- 500 x)) (abs x)) 0 500)\n                      closesty (if (&gt; (abs (- 500 y)) (abs y)) 0 500)]\n                  (println \&quot;bact\&quot; closestx closesty)\n                  #_(repulsion {:loc [closestx closesty] :mass 2} t)))}))&quot; &quot;(def borders \n    (element\n      {:mass  10000\n       :show  (fn [_] ())\n       :step  (fn [x] x)\n       :fixed true\n       :act   (fn [b {[x y] :loc :as t}]\n                (println \&quot;yo\&quot;)\n                (let [closestx (if (&gt; (abs (- 500 x)) (abs x)) 0 500)\n                      closesty (if (&gt; (abs (- 500 y)) (abs y)) 0 500)]\n                  (println \&quot;bact\&quot; closestx closesty)\n                  (repulsion {:loc [closestx closesty] :mass 2} t)))}))&quot; &quot;(act borders (first movers))&quot; &quot;(def movers\n    (map\n      (fn [_]\n        (element\n          {:vel  [(rand 1) (rand 1)]\n           :loc  [(rand 500) (rand 500)]\n           :show (fn [{[x y] :loc}] (fill 255 255 255) (ellipse x y 50 50))\n           :mass (rand-nth (range 0.5 2 0.25))\n           :act  gravitation\n           :age  (int (* 1000 (rand)))}))\n      (range 10)))&quot;], :remote []}}</component>
</project>